# 작업 분해 전략

> 복잡한 작업을 병렬 실행 가능한 단위로 분해하는 패턴

---

## 1. 분해 판단 플로우

```
[작업 입력]
    │
    ├─ 단일 대상? ──────────────────→ Depth 0 (직접 처리)
    │
    ├─ 복수 대상, 독립적? ──────────→ Depth 1 (1회 병렬)
    │   예: "파일 A, B, C 각각 분석"
    │
    ├─ 복수 대상, 각각 하위 작업? ──→ Depth 2 (재귀 병렬)
    │   예: "모든 모듈의 의존성 트리 분석"
    │
    └─ 대규모 + 단계별 의존? ──────→ Depth 3+ (파이프라인)
        예: "전체 코드베이스 리팩토링 계획"
```

---

## 2. Depth별 분해 패턴

### Depth 0: 직접 처리

분해하지 않고 현재 컨텍스트에서 처리.

```yaml
조건:
  - 단일 파일 또는 명확한 단일 대상
  - 컨텍스트 전환 오버헤드 > 이득

예시:
  - "이 함수 설명해줘"
  - "README.md 수정해줘"
```

### Depth 1: 1회 병렬

독립적인 N개 작업을 동시 실행.

```yaml
조건:
  - 2-5개의 명확한 독립 작업
  - 작업 간 데이터 공유 없음
  - 결과 단순 병합 가능

패턴:
  Task tool × N (단일 메시지에서)

예시:
  - "src/, lib/, utils/ 각각 구조 파악"
  - "TypeScript, Python, Go 파일 각각 카운트"
```

### Depth 2: 재귀 병렬

1차 결과를 기반으로 2차 병렬 실행.

```yaml
조건:
  - 1차 작업 결과가 2차 작업 입력
  - 2차 작업들은 서로 독립적

패턴:
  1단계: Task tool로 목록/구조 수집
  2단계: 수집 결과 기반 Task tool × N

예시:
  - "모든 컴포넌트 찾기 → 각 컴포넌트 props 분석"
  - "API 엔드포인트 목록 → 각 엔드포인트 보안 검토"
```

### Depth 3+: 파이프라인

단계별 의존성이 있는 대규모 작업.

```yaml
조건:
  - 3단계 이상의 처리 필요
  - 일부 단계는 순차, 일부는 병렬

패턴:
  Plan 에이전트로 전체 계획 수립 →
  각 단계를 Depth 1-2로 실행

예시:
  - "전체 아키텍처 분석 → 문제점 식별 → 개선안 제시"
  - "데이터 수집 → 정제 → 분석 → 시각화"
```

---

## 3. 분해 불가 케이스

### 순차 의존성

```
# 분해 불가
"파일 A 읽기 → A 기반으로 B 생성 → B 검증"

# 처리: 순차 실행 유지
```

### 공유 상태

```
# 분해 불가
"동일 파일에 여러 수정 적용"

# 처리: 단일 에이전트에서 순차 처리
```

### 트랜잭션

```
# 분해 불가
"설정 변경 + 마이그레이션 + 검증"

# 처리: 전체를 원자적으로 처리
```

---

## 4. 분해 휴리스틱

### 키워드 기반 힌트

| 키워드 | Depth 힌트 |
|--------|-----------|
| "각각", "모든", "전부" | ≥1 |
| "그리고 나서", "후에" | 순차 (분해 주의) |
| "동시에", "병렬로" | ≥1 (명시적 요청) |
| "분석", "검토", "조사" | ≥1 (탐색 작업) |
| "변경", "수정", "적용" | 0 또는 순차 (부작용) |

### 대상 수 기반

| 대상 수 | 권장 Depth |
|--------|-----------|
| 1 | 0 |
| 2-5 | 1 |
| 6-20 | 1-2 (배치 분할) |
| 20+ | 2+ (샘플링 고려) |

---

## 5. 분해 예제

### 예제 1: 코드베이스 탐색

```
요청: "이 프로젝트에서 사용하는 모든 외부 라이브러리와
       각각의 사용 위치를 알려줘"

분석:
- 복수 대상 (라이브러리들)
- 각각 하위 작업 (사용 위치 탐색)
- Depth 2

실행:
1단계: package.json, requirements.txt 등에서 의존성 목록 추출
2단계: 각 라이브러리별로 import/require 위치 탐색 (병렬)
```

### 예제 2: 보안 감사

```
요청: "모든 API 엔드포인트의 인증/인가 상태를 검토해줘"

분석:
- 복수 대상 (엔드포인트들)
- 각각 독립적 검토 가능
- Depth 2

실행:
1단계: 라우터/컨트롤러에서 엔드포인트 목록 수집
2단계: 각 엔드포인트별 미들웨어/데코레이터 분석 (병렬)
```

### 예제 3: 문서화

```
요청: "src/components/ 아래 모든 컴포넌트에 JSDoc 추가"

분석:
- 복수 대상 (컴포넌트 파일들)
- 부작용 있음 (파일 수정)
- Depth 1이지만 순차 권장

실행:
- 파일 목록 수집 후 순차적으로 수정
- 또는 사용자 확인 후 병렬 수정
```

---

## 6. 최적화 팁

### 배치 분할

대상이 많을 때 적절한 크기로 배치:

```
20개 파일 분석 요청:
- 5개 × 4 배치로 분할
- 각 배치를 병렬 에이전트로 처리
- 메모리/컨텍스트 효율화
```

### 조기 종료

충분한 결과 수집 시 나머지 건너뛰기:

```
"버그 원인 찾기" 요청:
- 여러 위치 병렬 탐색
- 원인 발견 시 다른 에이전트 중단 가능
```

### 샘플링

대규모 대상에서 대표 샘플만 분석:

```
"1000개 파일 코드 스타일 검토":
- 전체 대신 10% 랜덤 샘플
- 결과를 전체에 추정 적용
```
